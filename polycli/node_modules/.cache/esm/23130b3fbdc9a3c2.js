let fs,shell,tunnelpaper,req,parseString,utils;_bdc‍.x([["save_format_rcsb_profile",()=>save_format_rcsb_profile],["handle_rcsb",()=>handle_rcsb]]);_bdc‍.w("fs",[["default",["fs"],function(v){fs=v}]]);_bdc‍.w("shelljs",[["default",["shell"],function(v){shell=v}]]);_bdc‍.w("./../assets/kdd-paper-table",[["*",null,function(v){tunnelpaper=v}]]);_bdc‍.w("./requests",[["*",null,function(v){req=v}]]);_bdc‍.w("xml2js",[["parseString",["parseString"],function(v){parseString=v}]]);_bdc‍.w("./utils",[["*",null,function(v){utils=v}]]);








       const save_format_rcsb_profile = async (pdbid, depositionDirectory) => {
    if (!fs.existsSync(depositionDirectory)) {
        _bdc‍.g.console.log("Creating directory: ", depositionDirectory);
        shell.mkdir('-p', depositionDirectory);
    }
    try {
        console.log(`Downloading ${pdbid} from RCSB`)
        var rcsbProfile = await req.requestSanDiegoRNA(pdbid)
            .then(res => {
                var Options = {
                    trim: true,
                    mergeAttrs: true,
                    explicitArray: false,
                    attrNameProccessors: [],
                    attrValueProccessor: [],
                    tagNameProcessors: [],
                    valueProccessors: [],
                }
                var parsed;
                parseString(res.data, Options, (err, result) => {
                    parsed = result;
                    if (err) {
                        _bdc‍.g.console.log("Failed to parse rcsb's xml. Exiting  ", error)
                        process.exit(2)
                    }
                })
                return [pdbid, utils.restructureOnDownload(parsed)];
            }, err => { return [pdbid, { failedWith: err }] })

        fs.writeFileSync(depositionDirectory + `${rcsbProfile[0]}.json`, JSON.stringify(rcsbProfile[1], null, 4), 'utf8',
            () => { console.log(`${rcsbProfile[0]} saved to disk.\n`) })
    } catch (error) {
        _bdc‍.g.console.log('Error fetching / No matches ', error)
    }
}




       const handle_rcsb = async (templates) => {

    console.log(`RCSB got templates ${templates}`)
    var depositionDirectory = './static/rcsb/'
    

    // SINGLE PROCESSING
    if (templates[0] === 'single') {
        try {
            save_format_rcsb_profile( templates[1].toUpperCase() , depositionDirectory)
        } catch (error) {
            _bdc‍.g.console.log('Error fetching a single rcsb profie.', error)
        }
    }

    // BATCH PROCESSING
    else if (templates[0] === 'batch') {
        var targetmolecules = Object.keys(tunnelpaper.structs_kdd2019)
        _bdc‍.g.console.log("Attempting to download: ", targetmolecules, " to ", depositionDirectory);
        const promiseIndexed = targetmolecules.map(async mol => {
            return await save_format_rcsb_profile(mol, depositionDirectory)
        }
        )
        await Promise.all(promiseIndexed);
        return 0
    }


}